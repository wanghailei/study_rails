# Action View Helper

A helper is simply a module containing methods that assist a view. A helper extends the behavior of a template. Helper methods are output-centric, and they exist to generate HTML (or XML, or JavaScript).

It’s always a good practice to use Rails helpers where they’re appropriate, even if it seems just as easy to hard-code the output you want.

While all view helpers are available to all controllers, it’s often good practice to organize helpers. ==By default, each controller gets its own helper module.==

### ``link_to``

link_to creates a hyperlink to another action in your application.

```ruby
<%= link_to "Add Product", new_products_path %>
<%= link_to "Delete", product_path(@product), { class: "dangerous", method: 'delete' } %>
```

The ``:method`` option is a hack — it allows you to make the link look to the application as if the request were created by a `POST`, `PUT`, `PATCH`, or `DELETE`, rather than the normal `GET` method.

The most commonly used one is the `:confirm` option, which takes a short message. If present, an unobtrusive JavaScript driver will display the message and get the user’s confirmation before the link is followed.

```ruby
<%= link_to "Delete", product_path(@product), method: :delete, data: { confirm: 'Are you sure?' } %>
```

`link_to_if` and `link_to_unless` take a condition parameter, followed by the regular parameters to link_to. If the condition is true for `link_to_if` or false for `link_to_unless`, a regular link will be created using the remaining parameters. If not, the name will be added as plain text with no hyperlink.

#### `link_to_unless_current`

The `link_to_unless_current` helper creates menus in sidebars where the current page name is shown as plain text and the other entries are hyperlinks:

```ruby
<ul><% %w{ create list edit save logout }.each do |action| %>
	<li><%= link_to_unless_current( action.capitalize, action: action ) %></li>
<% end %></ul>
```

The `link_to_unless_current` helper may also be passed a block that’s evaluated only if the current action is the action given, effectively providing an alternative to the link. There’s also a `current_page` helper method that simply tests whether the current page was generated by the given options.

The `button_to` method works the same as link_to but generates a button in a self-contained form rather than a straight hyperlink.

#### `link_to image_tag`

```ruby
<%= link_to( image_tag("delete.png", size: "50x22"), product_path(@product), 
	data: { confirm: "Are you sure?" }, method: :delete ) %>
```



## form\_with

`form_with()` sets up a Ruby block environment, within which, the block’s parameter `f` is used to reference a `form` context.

Before form\_with was introduced in Rails 5.1, its functionality used to be split between form\_tag and form\_for. Both are now soft-deprecated.

### `form_with model:` Binding a Form to an Object

==The `form_with model:` helper sets up an HTML form that knows about Rails routes and models.==

```ruby
<%= form_with model: @order do |f| %>
    <%= f.label :name, "Name:" %>
    <%= f.text_field :name, size: 40 %>
<% end %>
```

The `:model` argument of `form_with` binds the form builder object to a model object. This association means that: 1) the form will be scoped to that model object, 2)the form's fields will be populated with values from that model object, and 3) submitting the form will set the right names and values in the data available to the controller.

### form\_with and RESTful resources

When dealing with RESTful resources, calls to `form_with` can get significantly easier if you rely on record identification. In short, you can just pass ==the model instance== and have Rails figure out model name and the rest.

The long and short style of editing an existing article have the same outcome:

```ruby
# long-style:
form_with( model: @article, url: article_path(@article), method: "patch" )

# short-style:
form_with( model: @article )
```

### Parameter Naming Conventions

Values from forms can be at the top level of the `params` hash or nested in another hash. For example, in a standard `create` action for a `Person` model, `params[:person]` would usually be a hash of all the attributes for the person to create. The `params` hash can also contain arrays, arrays of hashes, and so on.

Fundamentally HTML forms don't know about any sort of structured data, all they generate is name-value pairs, where pairs are just plain strings. The arrays and hashes you see in your application are the result of some parameter naming conventions that Rails uses.

### `<%= javascript_importmap_tags %>`

The `javascript_importmap_tags` method produces a list JavaScript filenames (assumed to live in app/javascript) which enables these resources to be imported by your application.

### `stylesheet_link_tag`

<%= stylesheet_link_tag "inter-font", "data-turbo-track": "reload" %>

<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>”

By default, image and style sheet assets are assumed to live in the `images` and `stylesheets` directories relative to the application’s `assets` directory.



### capture

In Rails, the `capture` method is a helper that takes a block, executes it, and returns the generated output as a string.

```ruby
<% @greeting = capture do %>
	<p>Welcome! The date and time is <%= Time.current %></p>
<% end %>
```

Once captured, the content is stored in `@greeting`. You can then output it later in your view using `<%= @greeting %>`. This pattern is particularly useful when you want to build reusable view components or delay rendering.

#### how is it possible that the `capture` method being used "globally" in an app without an object?

In Rails, helper methods like `capture` are defined as instance methods within modules (such as `ActionView::Helpers::CaptureHelper`) that are mixed into the view context. ==When a view is rendered, it’s evaluated in the context of an instance of `ActionView::Base`==, which includes these helper modules. This makes methods like `capture` available “globally” within views without needing an explicit receiver.

To summarize:

**Module Inclusion**: Rails includes helper modules (like CaptureHelper) into ActionView::Base.

**View Context**: Each view is evaluated in an object (an instance of ActionView::Base) where these methods are accessible.

**Implicit Receiver**: When you call capture in a view, Ruby looks it up in the current object (the view instance) and finds it there.

This is why you can call capture directly in your ERB templates without specifying an object—it’s already part of the view’s context.