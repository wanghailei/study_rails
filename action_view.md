# Action View

Action View encapsulates all the functionality needed to render templates, most commonly generating HTML, XML, or JavaScript back to the user.

## Templates

The `render` method expects to find templates in the app/views directory of the current application.

Within this directory, the convention is to have a separate subdirectory for the views of each controller. Each subdirectory typically contains templates named after the actions in the corresponding controller.

Templates contain a mixture of fixed text and code. The code in the template adds dynamic content to the response. That code runs in an environment that gives it access to the information set up by the controller:

All instance variables of the controller are also available in the template. This is how actions communicate data to the templates.

The path to the base directory of the templates is stored in the attribute base_path.

Jbuilder templates generate JSON responses.

In an ERB template, the ``debug`` method can be used to display the contents of the session, the details of the parameters, and the current response.

### Expose one instance variable per Action

The way Rails makes data from controllers available to views is ==by copying the *instance variables of the controller* into the view code as *instance variables with the same name*==.

The way to get the most of Rails’ design without creating a problem is to adopt two conventions:

- ==Expose exactly one instance variable from any given action, ideally named for the resource or resources being manipulated by the route to that action.== For example, the `widget` `show` page should only expose `@widget`. ==The key situation to avoid is exposing multiple instance variables that collectively represent the resource rather than creating a single instance variable (and perhaps a new model class) to do so.==

- There are there exceptions: when a view requires access to reference data, like a list of country codes, when the view needs access to global context, like the currently logged-in user, or when there is UI state that is persisted across page refreshes, such as the currently selected tab in a tab navigation control.

	

## Helper

A helper is simply a module containing methods that assist a view. A helper extends the behavior of a template. Helper methods are output-centric, and they exist to generate HTML (or XML, or JavaScript).

It’s always a good practice to use Rails helpers where they’re appropriate, even if it seems just as easy to hard-code the output you want.

While all view helpers are available to all controllers, it’s often good practice to organize helpers. By default, each controller gets its own helper module.

### ``link_to``

link_to creates a hyperlink to another action in your application.

```ruby
<%= link_to "Add Product", new_products_path %>
<%= link_to "Delete", product_path(@product), { class: "dangerous", method: 'delete' } %>
```

The ``:method`` option is a hack — it allows you to make the link look to the application as if the request were created by a `POST`, `PUT`, `PATCH`, or `DELETE`, rather than the normal `GET` method.

The most commonly used one is the `:confirm` option, which takes a short message. If present, an unobtrusive JavaScript driver will display the message and get the user’s confirmation before the link is followed.

```ruby
<%= link_to "Delete", product_path(@product), method: :delete, data: { confirm: 'Are you sure?' } %>
```

`link_to_if` and `link_to_unless` take a condition parameter, followed by the regular parameters to link_to. If the condition is true for `link_to_if` or false for `link_to_unless`, a regular link will be created using the remaining parameters. If not, the name will be added as plain text with no hyperlink.

### `link_to_unless_current`

The `link_to_unless_current` helper creates menus in sidebars where the current page name is shown as plain text and the other entries are hyperlinks:

```ruby
<ul><% %w{ create list edit save logout }.each do |action| %>
	<li><%= link_to_unless_current( action.capitalize, action: action ) %></li>
<% end %></ul>
```

The `link_to_unless_current` helper may also be passed a block that’s evaluated only if the current action is the action given, effectively providing an alternative to the link. There’s also a `current_page` helper method that simply tests whether the current page was generated by the given options.

The `button_to` method works the same as link_to but generates a button in a self-contained form rather than a straight hyperlink.

### `link_to image_tag`

```ruby
<%= link_to( image_tag("delete.png", size: "50x22"), product_path(@product), 
	data: { confirm: "Are you sure?" }, method: :delete ) %>
```



## form\_with

`form_with()` sets up a Ruby block environment, within which, the block’s parameter `f` is used to reference a `form` context.

Before form\_with was introduced in Rails 5.1 its functionality used to be split between form\_tag and form\_for. Both are now soft-deprecated.

### `form_with model:` Binding a Form to an Object

==The `form_with model:` helper sets up an HTML form that knows about Rails routes and models.==

```ruby
<%= form_with model: @order do |f| %>
    <%= f.label :name, "Name:" %>
    <%= f.text_field :name, size: 40 %>
<% end %>
```

The `:model` argument of `form_with` binds the form builder object to a model object. This association means that: 1) the form will be scoped to that model object, 2)the form's fields will be populated with values from that model object, and 3) submitting the form will set the right names and values in the data available to the controller.

### form\_with and RESTful resources

When dealing with RESTful resources, calls to `form_with` can get significantly easier if you rely on record identification. In short, you can just pass ==the model instance== and have Rails figure out model name and the rest.

The long and short style of editing an existing article have the same outcome:

```ruby
# long-style:
form_with( model: @article, url: article_path(@article), method: "patch" )

# short-style:
form_with( model: @article )
```

### Parameter Naming Conventions

Values from forms can be at the top level of the `params` hash or nested in another hash. For example, in a standard `create` action for a `Person` model, `params[:person]` would usually be a hash of all the attributes for the person to create. The `params` hash can also contain arrays, arrays of hashes, and so on.

Fundamentally HTML forms don't know about any sort of structured data, all they generate is name-value pairs, where pairs are just plain strings. The arrays and hashes you see in your application are the result of some parameter naming conventions that Rails uses.

### `<%= javascript_importmap_tags %>`

The `javascript_importmap_tags` method produces a list JavaScript filenames (assumed to live in app/javascript) which enables these resources to be imported by your application.

### `stylesheet_link_tag`

<%= stylesheet_link_tag "inter-font", "data-turbo-track": "reload" %>

<%= stylesheet_link_tag "application", "data-turbo-track": "reload" %>”

By default, image and style sheet assets are assumed to live in the `images` and `stylesheets` directories relative to the application’s `assets` directory.



## Layout





## Partial



***

## Turbo

==% 有 Turbo，可以讓 UI 局部刷新，且不用寫 Javascript。20231129 %==

Turbo speeds up Rails applications, reduces the amount of JavaScript we have to write, and makes it easy to work with real-time features.

1\. All clicks on links and form submissions are now AJAX requests, thanks to Turbo Drive. We get this benefit for free as it does not require any work; we only have to import the library.

2\. It is now effortless, with just a few lines of code to build dynamic applications by slicing pages in different pieces with Turbo Frames. We develop our CRUD controllers just like we did before, and just by adding a few lines of code, we can replace or lazy-load independent parts of the page!

3\. It becomes trivial to add real-time features with the help of Turbo Streams. Want to add real-time notifications to your application, build a real-time multiplayer game, or a real-time bug monitoring system? The real-time part is just a few lines of code with Turbo Stream!

## Stimulus

Stimulus is a JavaScript framework with modest ambitions. Unlike other front-end frameworks, Stimulus is designed to enhance server-rendered HTML by connecting JavaScript objects to elements on the page using simple annotations.

These JavaScript objects are called controllers, and Stimulus continuously monitors the page waiting for HTML `data-controller` attributes to appear. For each attribute, Stimulus looks at the attribute’s value to find a corresponding controller class, creates a new instance of that class, and connects it to the element.

You can think of it this way: just like the class attribute is a bridge connecting HTML to CSS, Stimulus’s `data-controller` attribute is a bridge connecting HTML to JavaScript.

Aside from controllers, the three other major Stimulus concepts are:

\- actions, which connect controller methods to DOM events using data-action attributes

\- targets, which locate elements of significance within a controller.

Targets Map Important Elements To Controller Properties.

\- values, which read, write, and observe data attributes on the controller’s element

Stimulus’s use of data attributes helps separate content from behaviour in the same way CSS separates content from presentation.

==Stimulus helps you build small, reusable controllers, giving you just enough structure to keep your code from devolving into “JavaScript soup.”==



